// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IReserveHolder {
  event SetArbitrager(address indexed arbitrager, bool enabled);
  event SetClaimer(address indexed claimer);
  event SetEthThreshold(uint256 threshold);
  event SetSwapEthTolerance(uint256 tolerance);
  event SetCurveStEthSafeGuardPercentage(uint256 percentage);
  event Deposit(address indexed account, uint256 amount);
  event Rebalance(uint256 ethAmount, uint256 stEthAmount);
  event Redeem(address indexed account, uint256 amount);
  event RedeemSwap(uint256 ethAmount, uint256 stEthAmount);
  event ClaimRewards(address indexed account, uint256 amount);
  event Receive(address indexed account, uint256 amount);

  error NotArbitrager(address _account);
  error NotClaimer(address _account);
  error ThresholdTooHigh(uint256 _threshold);
  error SafeGuardTooHigh(uint256 _safeGuard);
  error EtherSendFailed(address _account, uint256 _amount);

  /// @notice Updates arbitrager status
  /// @param arbitrager Arbitrager address
  /// @param status Arbitrager status
  function setArbitrager(address arbitrager, bool status) external;

  /// @notice Sets claimer address
  /// @param claimer Claimer address
  /// @custom:usage Claimer should be rewardController contract
  function setClaimer(address claimer) external;

  /// @notice Sets eth threshold
  /// @param ethThreshold Eth threshold
  /// @custom:usage Eth threshold should be set in percentage
  /// @custom:usage Part of reserves is in WETH so arbitrage contract can use them without swapping stETH for ETH
  function setEthThreshold(uint256 ethThreshold) external;

  /// @notice Sets swap eth tolerance
  /// @param swapEthTolerance Swap eth tolerance
  /// @custom:usage Swap eth tolerance should be set in wei
  /// @custom:usage Absolute tolerance for swapping stETH for ETH
  function setSwapEthTolerance(uint256 swapEthTolerance) external;

  /// @notice Sets curve stETH safe guard percentage
  /// @param curveStEthSafeGuardPercentage Curve stETH safe guard percentage
  function setCurveStEthSafeGuardPercentage(uint256 curveStEthSafeGuardPercentage) external;

  /// @notice Gets reserve value in USD
  /// @return reserveValue Reserve value in USD
  function getReserveValue() external view returns (uint256 reserveValue);

  /// @notice Gets current rewards generated by stETH
  /// @return currentRewards Current rewards generated by stETH
  function getCurrentRewards() external view returns (uint256 currentRewards);

  /// @notice Gets cumulative rewards generated by stETH
  /// @return cumulativeRewards Cumulative rewards generated by stETH
  function getCumulativeRewards() external view returns (uint256 cumulativeRewards);

  /// @notice Deposits stETH to reseves
  /// @param amount Amount of stETH to deposit
  function deposit(uint256 amount) external;

  /// @notice Rebalance reserve in order to achieve balace/ethThreshold ratio
  /// @dev If there is more WETH than ethThreshold then unwrap WETH and get stETH from Lido
  /// @dev If there is less WETH than ethThreshold then swap stETH for WETH on UniV2
  /// @custom:usage This function should be called by external keeper
  function rebalance() external;

  /// @notice Redeems stETH from reserves
  /// @param amount Amount of stETH to redeem
  /// @return wethAmount Amount of WETH received
  /// @custom:usage This function should be called by arbitrage contract
  function redeem(uint256 amount) external returns (uint256 wethAmount);

  /// @notice Claims stETH rewards in given amount for given account
  /// @notice Contract does not perform any check and is relying on rewardController contract to perform them
  /// @param account Account to claim stETH rewards for
  /// @param amount Amount of stETH to claim
  /// @custom:usage This function should be called by rewardController contract
  function claimRewards(address account, uint256 amount) external;

  /// @notice Wrapps ETH to WETH
  /// @dev Users can buy USC with ETH which is transfered to this contract. This function should be called to wrapp than ETH to WETH
  /// @custom:usage This function should be called by external keeper
  function wrapETH() external;
}
